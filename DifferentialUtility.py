import numpy as np

def secondPartialDerivativeX(prev, dx):
    ''' Calculates a numerical approximation for the second partial derivative wrt x in a 2-dimensional
    domain using the forward finite difference method. Notice that this requires boundary points to calculate,
    so the derivative can only be calculated in the interior.

    Args:
        prev: the surface generated by a function over a 2-D domain
        dx: the distance between points in our domain in the x-direction

    Returns:
        the approximate second derivative in the x-direction of an unspecified function f: R^2 -> R
    '''

    d2x = np.copy(prev)
    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            d2x[i, j] = (prev[i+1, j] - (2*prev[i, j]) + prev[i-1, j])/(dx**2)

    return d2x

def secondPartialDerivativeY(prev, dy):
    ''' Calculates a numerical approximation for the second partial derivative wrt y in a 2-dimensional
    domain using the forward finite difference method. Notice that this requires boundary points to calculate,
    so the derivative can only be calculated in the interior.

    Args:
        prev: the surface generated by a function over a 2-D domain
        dy: the distance between points in our domain in the y-direction

    Returns:
        the approximate second derivative in the y-direction of an unspecified function f: R^2 -> R
    '''

    d2y = np.copy(prev)
    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            d2y[i, j] = (prev[i, j+1] - (2*prev[i, j]) + prev[i, j-1])/(dy**2)

    return d2y

def partialDerivativeX(prev, dx):
    ''' Calculates a numerical approximation for the first partial derivative wrt x in a 2-dimensional
    domain using the centered finite difference method. Notice that this requires boundary points to calculate,
    so the derivative can only be calculated in the interior.

    Args:
        prev: the surface generated by a function over a 2-D domain
        dx: the distance between points in our domain in the x-direction

    Returns:
        the approximate first derivative in the x-direction of an unspecified function f: R^2 -> R
    '''

    dudx = np.copy(prev)
    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            dudx[i, j] = (prev[i+1, j] - prev[i-1, j])/(2*dx)
    
    return dudx

def partialDerivativeY(prev, dy):
    ''' Calculates a numerical approximation for the first partial derivative wrt y in a 2-dimensional
    domain using the centered finite difference method. Notice that this requires boundary points to calculate,
    so the derivative can only be calculated in the interior.

    Args:
        prev: the surface generated by a function over a 2-D domain
        dy: the distance between points in our domain in the y-direction

    Returns:
        the approximate first derivative in the y-direction of an unspecified function f: R^2 -> R
    '''

    dudy = np.copy(prev)
    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            dudy[i, j] = (prev[i, j+1] - prev[i, j-1])/(2*dy)
    
    return dudy

def mixedPartial(prev, dx, dy):
    ''' Calculates a numerical approximation for the mixed partial derivative wrt x then y in a 2-dimensional
    domain using the centered finite difference method. Notice that this requires boundary points to calculate,
    so the derivative can only be calculated in the interior.

    Args:
        prev: the surface generated by a function over a 2-D domain
        dx: the distance between points in our domain in the x-direction
        dy: the distance between points in our domain in the x-direction

    Returns:
        the approximate mixed partial derivative wrt x then y of an unspecified function f: R^2 -> R
    '''

    dudxdy = np.copy(prev)
    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            dudxdy[i, j] = (prev[i+1, j+1] - prev[i-1, j+1] - prev[i+1, j-1] + prev[i-1, j-1])/(4*dx*dy)
    
    return dudxdy

def heatEquationPartials(prev, dx, dy):
    ''' Generates the spatial derivatives used in the 2-D heat equation Ut = Uxx + Uyy

    Args:
        prev: the surface generated by a function over a 2-D domain
        dx: the distance between points in our domain in the x-direction
        dy: the distance between points in our domain in the x-direction

    Returns:
        a tuple of the approximated derivatives used in the 2-D heat equation
    '''

    uxx = np.copy(prev)
    uyy = np.copy(prev)

    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            uxx[i, j] = (prev[i+1, j] - (2*prev[i, j]) + prev[i-1, j])/(dx**2)
            uyy[i, j] = (prev[i, j+1] - (2*prev[i, j]) + prev[i, j-1])/(dy**2)

    return (uxx, uyy)


def levelSetPartials(prev, dx, dy):
    ''' Generates the spatial derivatives used in the 2-D Level-Set equation Ut = ( (Ux^2 * Uyy) - 2 * (Ux * Uy * Uxy) + (Uy^2 * Uxx) ) / (Uxx^2 + Uyy^2)

    Args:
        prev: the surface generated by a function over a 2-D domain
        dx: the distance between points in our domain in the x-direction
        dy: the distance between points in our domain in the x-direction

    Returns:
        a tuple of the approximated derivatives used in the 2-D Level-Set Equation
    '''

    ux = np.copy(prev)
    uy = np.copy(prev)
    uxx = np.copy(prev)
    uyy = np.copy(prev)
    uxy = np.copy(prev)

    for i in range(1, len(prev) - 1):
        for j in range(1, len(prev[i]) - 1):
            uxy[i, j] = (prev[i+1, j+1] - prev[i-1, j+1] - prev[i+1, j-1] + prev[i-1, j-1])/(4*dx*dy)
            uy[i, j] = (prev[i, j+1] - prev[i, j-1])/(2*dy)
            ux[i, j] = (prev[i+1, j] - prev[i-1, j])/(2*dx)
            uyy[i, j] = (prev[i, j+1] - (2*prev[i, j]) + prev[i, j-1])/(dy**2)
            uxx[i, j] = (prev[i+1, j] - (2*prev[i, j]) + prev[i-1, j])/(dx**2)

    return [ux, uy, uxy, uxx, uyy]